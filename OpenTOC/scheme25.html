<html xmlns:bkstg="http://www.atypon.com/backstage-ns" xmlns:urlutil="java:com.atypon.literatum.customization.UrlUtil" xmlns:pxje="java:com.atypon.frontend.services.impl.PassportXslJavaExtentions">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
      <meta http-equiv="Content-Style-Type" content="text/css">
      <style type="text/css">
            #DLtoc {
            font: normal 12px/1.5em Arial, Helvetica, sans-serif;
            }

            #DLheader {
            }
            #DLheader h1 {
            font-size:16px;
            }

            #DLcontent {
            font-size:12px;
            }
            #DLcontent h2 {
            font-size:14px;
            margin-bottom:5px;
            }
            #DLcontent h3 {
            font-size:12px;
            padding-left:20px;
            margin-bottom:0px;
            }

            #DLcontent ul{
            margin-top:0px;
            margin-bottom:0px;
            }

            .DLauthors li{
            display: inline;
            list-style-type: none;
            padding-right: 5px;
            }

            .DLauthors li:after{
            content:",";
            }
            .DLauthors li.nameList.Last:after{
            content:"";
            }

            .DLabstract {
            padding-left:40px;
            padding-right:20px;
            display:block;
            }

            .DLformats li{
            display: inline;
            list-style-type: none;
            padding-right: 5px;
            }

            .DLformats li:after{
            content:",";
            }
            .DLformats li.formatList.Last:after{
            content:"";
            }

            .DLlogo {
            vertical-align:middle;
            padding-right:5px;
            border:none;
            }

            .DLcitLink {
            margin-left:20px;
            }

            .DLtitleLink {
            margin-left:20px;
            }

            .DLotherLink {
            margin-left:0px;
            }

        </style>
      <title>Scheme '25: Proceedings of the 26th ACM SIGPLAN International Workshop on Scheme and Functional Programming</title>
   </head>
   <body>
      <div id="DLtoc">
         <div id="DLheader">
            <h1>Scheme '25: Proceedings of the 26th ACM SIGPLAN International Workshop on Scheme and Functional
               Programming</h1><a class="DLcitLink" title="Go to the ACM Digital Library for additional information about this proceeding" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/proceedings/10.1145/3759537"><img class="DLlogo" alt="Digital Library logo" height="30" src="https://dl.acm.org/specs/products/acm/releasedAssets/images/footer-logo1.png">
               Full Citation in the ACM Digital Library
               </a></div>
         <div id="DLcontent">
            <h2>SESSION: Invited Contributions</h2>
            							
            <h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3759537.3771265">Scheme and New Frontiers for Language Design (Keynote)</a></h3>
            <ul class="DLauthors">
               <li class="nameList Last">Michael D. Adams</li>
            </ul>
            <div class="DLabstract">
               <div style="display:inline">
                  				
                  <p>Scheme has long served as a vibrant platform for exploring programming-language ideas
                     and advancing programming-language concepts. From contracts to macros and from continuations
                     to growing languages, it is a dynamic environment for reconceptualizing how we program.
                     
                     </p>
                  
                  <p>
                     In this keynote, I present several underexplored language-design directions that hold
                     significant potential. Due to Scheme's rich history and design, it is uniquely positioned
                     to lead the development of these ideas. For example, supporting more sophisticated
                     continuation structures and more expressive macro systems. These directions point
                     to new frontiers where we can push the boundaries of how programs are structured and
                     how we think about programming.</p>
                  			</div>
            </div>
            							
            						
            							
            <h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3759537.3771266">Scheme Reports at Fifty: Where Do We Go from Here? (Status Update from the R7RS Large
                  Committee)</a></h3>
            <ul class="DLauthors">
               <li class="nameList Last">Daphne Preston-Kendal</li>
            </ul>
            <div class="DLabstract">
               <div style="display:inline">
                  				
                  <p>On 22 December 2025, Scheme will celebrate its 50th birthday with the anniversary
                     of the publication of the first Scheme report. As chair of the current Scheme reports
                     working group, I have the daunting task of laying a foundation for the Scheme language
                     to successfully move onwards into its next fifty years. 
                     </p>
                  
                  <p>
                     The recent development of this series of reports has been marked by an acrimonious
                     split over R6RS vs R7RS small, followed by the prolonged and still ongoing gestation
                     of the R7RS large report. The Scheme language itself survived these battles: new Schemers
                     are still discovering the language; new projects in Scheme are still pushing forward
                     the cutting edge of computer science and engineering practice; the landscape of implementations
                     is as lively as ever. But the Scheme reports find themselves in new surroundings,
                     one into which R7RS large has to adapt itself. 
                     </p>
                  
                  <p>
                     What function does the Scheme report serve for the community now? What does the community
                     want to see in the Scheme report, and how do we continue to reconcile diverging visions
                     for the future of the language? How do we build a working group that represents the
                     diversity of opinions on the nature of Scheme and the best direction for its future?
                     This presentation will be an invitation to discuss these questions and more, as well
                     as an invitation to Schemers of all generations to join us in building R7RS large
                     as a good home for all Schemers to live in.</p>
                  			</div>
            </div>
            							
            						
            <h2>SESSION: Papers</h2>
            							
            <h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3759537.3762694">Checking a Denotational Semantics of Scheme in Agda</a></h3>
            <ul class="DLauthors">
               <li class="nameList Last">Peter D. Mosses</li>
            </ul>
            <div class="DLabstract">
               <div style="display:inline">
                  				
                  <p>The authoritative standards for the algorithmic language Scheme are the Scheme reports.
                     Most of the revised reports include a denotational semantics for primitive Scheme
                     expressions and selected procedures. </p>
                  <p>This paper first traces the history of the semantic definition, and summarizes its
                     form and content. It then presents a shallow embedding of denotational semantics into
                     the functional programming language Agda. The embedding is illustrated by showing
                     how fragments of the denotational semantics given in the fifth revised Scheme report
                     (R<sup>5</sup>RS) are embedded into Agda. </p>
                  <p>Type-checking the Agda embedding of a semantics indirectly tests its wellformedness.
                     Agda reported several issues with the embedding of the complete denotational semantics
                     from R<sup>5</sup>RS. The paper suggests changes to the semantics that would address the reported issues,
                     as well as further changes that could improve the conciseness and perspicuity of the
                     definitions. </p>
                  <p> <em>This paper is dedicated to the memory of  </em><em>Christopher Strachey</em> (1916–1975) </p>
                  			</div>
            </div>
            							
            						
            							
            <h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3759537.3762693">Rewriting Macros on the Fly: A Modular Approach to Administrative Reduction during Expansion</a></h3>
            <ul class="DLauthors">
               <li class="nameList Last">Paul Downen</li>
            </ul>
            <div class="DLabstract">
               <div style="display:inline">
                  				
                  <p>Administrative reductions are extra steps introduced by program transformations, usually
                     as a form of bookkeeping new information needed by the transformation. While this
                     can keep transformations themselves simple and small, they have the unfortunate effect
                     of making the programs they produce more costly in terms of run-time resources and---worse
                     still---cognitive resources used by humans trying to read and debug their code. This
                     paper introduces a general-purpose technique for eliminating administrative expressions
                     in macros using localized rewriting rules. The result is a system of writing and rewriting
                     compositional macros (both in the sense that the macros are defined as compositional
                     functions, and that several different macros can be combined without administrative
                     reductions) that can be extended by the programmer with new functionality.</p>
                  			</div>
            </div>
            							
            						
            							
            <h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3759537.3762696">Fast and Extensible Hybrid Embeddings with Micros</a></h3>
            <ul class="DLauthors">
               <li class="nameList">Sean Bocirnea</li>
               <li class="nameList Last">William J. Bowman</li>
            </ul>
            <div class="DLabstract">
               <div style="display:inline">
                  				
                  <p>Macro embedding is a popular approach to defining extensible shallow embeddings of
                     object languages in Scheme-like host languages. While macro embedding has even been
                     shown to enable implementing extensible typed languages in systems like Racket, it
                     comes at a cost: compile-time performance. In this paper, we revisit <em>micros</em>—syntax to intermediate representation (IR) transformers, rather than source syntax
                     to source syntax transformers (macros). Micro embedding enables stopping at an IR,
                     producing a deep embedding and enabling high performance compile-time functions over
                     an efficient IR, before shallowly embedding the IR back into source syntax. Combining
                     micros with several design patterns to enable the IR and functions over it to be extensible,
                     we achieve extensible hybrid embedding of statically typed languages with significantly
                     improved compile-time compared to macro-embedding approaches. We describe our design
                     patterns and propose new abstractions packaging these patterns.</p>
                  			</div>
            </div>
            							
            						
            							
            <h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3759537.3762695">Hygienic Macros via Staged Environment Machines (Position Paper)</a></h3>
            <ul class="DLauthors">
               <li class="nameList Last">Yuito Murase</li>
            </ul>
            <div class="DLabstract">
               <div style="display:inline">
                  				
                  <p>The relationship between staged computation and procedural macros is often mentioned
                     in the literature. However, this relationship is not as straightforward as it may
                     appear. Existing approaches tend to compromise the role of macros as syntactic extensions,
                     focusing primarily on staged type systems to enforce the static safety of macros.
                     
                     </p>
                  
                  <p>
                     In this position paper, we propose a different approach to connecting procedural macros
                     and staged computation: to understand the semantic aspect of procedural macros through
                     the lens of staged computation. We observe that the notion of a syntactic environment
                     in hygienic macros has a natural counterpart in a staged extension of environment
                     machines. Building on this observation, we sketch our draft design of an environment
                     machine for a Lisp-like language with an explicit-renaming macro facility à la Clinger.</p>
                  			</div>
            </div>
            							
            						</div>
      </div>
   </body>
</html>