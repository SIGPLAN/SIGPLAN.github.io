<html xmlns:bkstg="http://www.atypon.com/backstage-ns" xmlns:urlutil="java:com.atypon.literatum.customization.UrlUtil" xmlns:pxje="java:com.atypon.frontend.services.impl.PassportXslJavaExtentions">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
      <meta http-equiv="Content-Style-Type" content="text/css">
      <style type="text/css">
            #DLtoc {
            font: normal 12px/1.5em Arial, Helvetica, sans-serif;
            }

            #DLheader {
            }
            #DLheader h1 {
            font-size:16px;
            }

            #DLcontent {
            font-size:12px;
            }
            #DLcontent h2 {
            font-size:14px;
            margin-bottom:5px;
            }
            #DLcontent h3 {
            font-size:12px;
            padding-left:20px;
            margin-bottom:0px;
            }

            #DLcontent ul{
            margin-top:0px;
            margin-bottom:0px;
            }

            .DLauthors li{
            display: inline;
            list-style-type: none;
            padding-right: 5px;
            }

            .DLauthors li:after{
            content:",";
            }
            .DLauthors li.nameList.Last:after{
            content:"";
            }

            .DLabstract {
            padding-left:40px;
            padding-right:20px;
            display:block;
            }

            .DLformats li{
            display: inline;
            list-style-type: none;
            padding-right: 5px;
            }

            .DLformats li:after{
            content:",";
            }
            .DLformats li.formatList.Last:after{
            content:"";
            }

            .DLlogo {
            vertical-align:middle;
            padding-right:5px;
            border:none;
            }

            .DLcitLink {
            margin-left:20px;
            }

            .DLtitleLink {
            margin-left:20px;
            }

            .DLotherLink {
            margin-left:0px;
            }

        </style>
      <title>PAINT '25: Proceedings of the 4th ACM SIGPLAN International Workshop on Programming Abstractions and Interactive Notations, Tools, and Environments</title>
   </head>
   <body>
      <div id="DLtoc">
         <div id="DLheader">
            <h1>PAINT '25: Proceedings of the 4th ACM SIGPLAN International Workshop on Programming Abstractions
               and Interactive Notations, Tools, and Environments</h1><a class="DLcitLink" title="Go to the ACM Digital Library for additional information about this proceeding" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/proceedings/10.1145/3759534"><img class="DLlogo" alt="Digital Library logo" height="30" src="https://dl.acm.org/specs/products/acm/releasedAssets/images/footer-logo1.png">
               Full Citation in the ACM Digital Library
               </a></div>
         <div id="DLcontent">
            <h2>SESSION: Invited Talk</h2>
            							
            <h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3759534.3771267">Notational Freedom via Self-Raising Diagrams (Invited Talk)</a></h3>
            <ul class="DLauthors">
               <li class="nameList Last">Joel Jakubovic</li>
            </ul>
            <div class="DLabstract">
               <div style="display:inline">
                  				
                  <p>Some things are better drawn than coded. However, it takes a lot of work to build
                     a custom editing interface for each new notation, discouraging experimentation. There
                     has to be a better way than Greenspunning poor approximations of Adobe Illustrator
                     over and over again. "Self-raising diagrams" are a promising escape from this trap.
                     Just as source code — a static artefact — "raises itself" into a dynamic running program,
                     a vector graphics diagram — taken to generalise source code — can similarly be parsed,
                     interpreted, and "animated" into a GUI. Notational engineers can then focus on the
                     notations themselves, and their semantics, having left the implementation of drawing
                     interfaces to the experts (implementors of standard vector graphics editors). The
                     tasks of normalising, interpreting, and transforming vector notations contain many
                     relevant problems for the notational engineer — far more relevant than coding line
                     rubberbanding for the umpteenth time!</p>
                  			</div>
            </div>
            							
            						
            <h2>SESSION: Papers</h2>
            							
            <h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3759534.3762681">Block-Based Editing in a Textual World</a></h3>
            <ul class="DLauthors">
               <li class="nameList">Tom Beckmann</li>
               <li class="nameList">Lukas Böhme</li>
               <li class="nameList">Marcel Taeumel</li>
               <li class="nameList Last">Robert Hirschfeld</li>
            </ul>
            <div class="DLabstract">
               <div style="display:inline">
                  				
                  <p>Block-based programming environments offer unique benefits for editing or integration
                     of visual tools that could be useful across programming environments. However, most
                     general-purpose programming environments are designed around textual representations
                     of programs.  
                     </p>
                  
                  <p>
                     We explore the design of a block-based editor that integrates with existing textual
                     environments, using the example of the Squeak/Smalltalk development environment. Through
                     a user study, we show that users felt generally comfortable with our editor’s edit
                     interactions when compared to textual editing. We discuss the design's difficulties
                     and opportunities we observed during our user study and our own use to help propose
                     block-based editor designs that integrate well with text-based environments.</p>
                  			</div>
            </div>
            							
            						
            							
            <h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3759534.3762682">Toward Bridging the Tool Gap: Equipping Large Language Models with Tools to Answer
                  Programmers’ Questions</a></h3>
            <ul class="DLauthors">
               <li class="nameList">Lukas Böhme</li>
               <li class="nameList">Christoph Thiede</li>
               <li class="nameList">Toni Mattis</li>
               <li class="nameList">Tom Beckmann</li>
               <li class="nameList">Jens Lincke</li>
               <li class="nameList Last">Robert Hirschfeld</li>
            </ul>
            <div class="DLabstract">
               <div style="display:inline">
                  				
                  <p>Programmers ask complex questions in their search for solutions during software development.
                     
                     Along with traditional tools such as debuggers and profilers, state-of-the-art approaches
                     like Babylonian Programming can help programmers answer those questions through interactive
                     and visual feedback. 
                     Large language models (LLMs) and programming agents are part of programmers' toolboxes
                     and are well-integrated into their development workflows. 
                     However, they are not yet helpful in considering questions involving run-time behavior.
                     
                     </p>
                  
                  <p>
                     In this paper, we first review the literature to identify concerns programmers face
                     during development and highlight how humans usually address them. 
                     We then focus on questions about program behavior and propose integrating Babylonian-style
                     programming techniques with LLMs to help answer related questions. 
                     Finally, we suggest four key properties that future LLM-based development tools should
                     support: (1) LLM tool usage traceability for explainability, (2) resumability of development
                     progress for handovers between human programmers and LLM-based programming agents,
                     (3) context efficiency through selective data querying, and (4) multi-source synthesis
                     for tool integration.</p>
                  			</div>
            </div>
            							
            						
            							
            <h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3759534.3762683">TIDE: An Educational Live Programming Environment to Compose Graphics with PyTamaro</a></h3>
            <ul class="DLauthors">
               <li class="nameList">Joey Bevilacqua</li>
               <li class="nameList">Nathan Coquerel</li>
               <li class="nameList">Luca Chiodini</li>
               <li class="nameList">Igor Moreno Santos</li>
               <li class="nameList Last">Matthias Hauswirth</li>
            </ul>
            <div class="DLabstract">
               <div style="display:inline">
                  				
                  <p>The PyTamaro approach to introductory programming  
                     equates <em>composing a program</em> to <em>composing a graphic</em>.  
                     Using the simple PyTamaro library for Python,  
                     beginner programmers compose function calls  
                     that produce primitive graphics, such as  
                     rectangle(20, 10, red),  
                     with function calls that combine graphics into composites,  
                     such as above(_, _).  
                     
                     To ease students into programming,  
                     several school teachers have been using TamaroCards,  
                     a paper-based visual language  
                     that can express the subset of Python  
                     needed to compose simple graphics with PyTamaro.  
                     
                     This paper introduces TIDE,  
                     the TamaroCards IDE,  
                     a web-based environment  
                     to complement the unplugged, paper-based TamaroCards.  
                     Given the constraints imposed by the Python programming language,  
                     the PyTamaro library, and the TamaroCards notation,  
                     the paper explores the design space for an interactive TamaroCards  
                     programming environment,  
                     describes a design  
                     that satisfies the pedagogical needs, and  
                     evaluates the implemented design using  
                     the Cognitive Dimensions framework.</p>
                  			</div>
            </div>
            							
            						
            							
            <h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3759534.3762684">The MNL: A Block-Based Functional Programming Language with Reactive Blocks</a></h3>
            <ul class="DLauthors">
               <li class="nameList Last">Steven Lolong</li>
            </ul>
            <div class="DLabstract">
               <div style="display:inline">
                  				
                  <p>The complexity of functional programming languages can pose a challenge for learners.
                     However, the use of block-based languages in learning programming can lower the barriers
                     to the learning process. While many block languages have been created, they often
                     lack essential features of functional languages and do not include the type inference.
                     
                     </p>
                  
                  <p>
                     This gap serves as motivation to develop a block-based functional programming language
                     that provides visual information about three programming language conventions. The
                     development process begins with designing text syntax, transforming it into blocks,
                     drafting typing rules for visual languages, and building a new functional block language
                     called Macaca Nigra Language.  
                     </p>
                  
                  <p>
                     Case studies of Macaca Nigra Language demonstrate that it effectively provides visual
                     clues through shapes and colors regarding the three conventions of programming languages.</p>
                  			</div>
            </div>
            							
            						</div>
      </div>
   </body>
</html>